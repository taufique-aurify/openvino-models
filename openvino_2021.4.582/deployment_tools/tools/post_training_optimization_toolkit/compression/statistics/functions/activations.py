#
# Copyright 2020-2021 Intel Corporation.
#
# LEGAL NOTICE: Your use of this software and any required dependent software
# (the "Software Package") is subject to the terms and conditions of
# the Intel(R) OpenVINO(TM) Distribution License for the Software Package,
# which may also include notices, disclaimers, or license terms for
# third party or open source software included in or with the Software Package,
# and your use indicates your acceptance of all such terms. Please refer
# to the "third-party-programs.txt" or other similarly-named text file
# included with the Software Package for additional details.
from functools import partial

import numpy as np
from ..function_selector import ACTIVATIONS_STATS_FN, PERTENSOR, PERCHANNEL

act_stats_fn_per_tensor = ACTIVATIONS_STATS_FN[PERTENSOR]
act_stats_fn_per_channel = ACTIVATIONS_STATS_FN[PERCHANNEL]


# helper functions to calculate statistics for activations
def calculate_per_channel_stats(acts, fn, axis=1):
    """ Calculates per-channel statistics for activations using a specific function
    :param act: activation
    :param fn: function to calculate per-channel statistics
    :return statistics generated by fn for each activation in the batch
    """
    if len(acts.shape) < 3:
        return acts
    acts = np.moveaxis(acts, axis, 1)
    t = acts.reshape(acts.shape[0], acts.shape[1], -1)
    return fn(t, axis=2)


def calculate_per_tensor_stats(acts, fn):
    """ Calculates statistics by whole tensor for activations using a specific function
    :param act: activation
    :param fn: function to calculate per-tensor statistics
    :return statistics generated by fn for each activation in the batch
    """
    if len(acts.shape) < 2:
        return np.atleast_1d(fn(acts))

    t = acts.reshape(acts.shape[0], -1)
    return fn(t, axis=1)


@act_stats_fn_per_tensor.register('max')
def max_per_tensor(acts):
    return calculate_per_tensor_stats(acts, np.max)


@act_stats_fn_per_tensor.register('min')
def min_per_tensor(acts):
    return calculate_per_tensor_stats(acts, np.min)


@act_stats_fn_per_tensor.register('abs_max')
def abs_max_per_tensor(acts):
    return max_per_tensor(np.abs(acts))


@act_stats_fn_per_tensor.register('quantile')
def quantile_per_tensor(acts, q):
    return calculate_per_tensor_stats(acts, partial(np.quantile, q=q))


@act_stats_fn_per_tensor.register('abs_quantile')
def abs_quantile_per_tensor(acts, q):
    return quantile_per_tensor(np.abs(acts), q)


@act_stats_fn_per_channel.register('mean')
def mean_per_channel(acts):
    return calculate_per_channel_stats(acts, np.mean)


@act_stats_fn_per_channel.register('mean_axis')
def mean_per_channel_axis(acts, layer_key=None, **kwargs):
    axis = kwargs.get('channel', {}).get(layer_key, 1)
    return calculate_per_channel_stats(acts, np.mean, axis=axis)


@act_stats_fn_per_channel.register('quantile')
def quantile_per_channel(acts, q):
    return calculate_per_channel_stats(acts, partial(np.quantile, q=q))


@act_stats_fn_per_channel.register('max')
def max_per_channel(acts):
    return calculate_per_channel_stats(acts, np.max)


@act_stats_fn_per_channel.register('min')
def min_per_channel(acts):
    return calculate_per_channel_stats(acts, np.min)


@act_stats_fn_per_channel.register('abs_max')
def abs_max_per_channel(acts):
    return max_per_channel(np.abs(acts))


@act_stats_fn_per_channel.register('abs_quantile')
def abs_quantile_per_channel(acts, q):
    return quantile_per_channel(np.abs(acts), q)
